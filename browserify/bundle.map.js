{
  "version": 3,
  "sources": [
    "../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "GenModel.js",
    "glm_model.js",
    "main.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "/* Generated from Java with JSweet 3.0.0 - http://www.jsweet.org */\n/**\n * ''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n * JAKE'S EDITS (REMOVED MOST CALLS TO H2O CLASSES!!)\n * ''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n * This is a helper class to support Java generated models.\n * @class\n */\nclass GenModel {\n    static correctProbabilities(scored, priorClassDist, modelClassDist) {\n        let probsum = 0;\n        for (let c = 1; c < scored.length; c++) {\n            {\n                const original_fraction = priorClassDist[c - 1];\n                const oversampled_fraction = modelClassDist[c - 1];\n                if (original_fraction !== 0 && oversampled_fraction !== 0)\n                    scored[c] *= original_fraction / oversampled_fraction;\n                probsum += scored[c];\n            }\n            ;\n        }\n        if (probsum > 0)\n            for (let i = 1; i < scored.length; ++i) {\n                scored[i] /= probsum;\n            }\n        return scored;\n    }\n    /**\n     * Utility function to get a best prediction from an array of class\n     * prediction distribution.  It returns the index of the max. probability (if that exists).\n     * In the case of ties, it samples from the tied classes with the likelihood given by the prior probabilities.\n     * @param {double[]} preds an array of prediction distribution.  Length of arrays is equal to a number of classes+1.\n     * @param {double[]} priorClassDist prior class probabilities (used to break ties)\n     * @param {double[]} data Test data\n     * @param {number} threshold threshold for binary classifier\n     * @return {number} the best prediction (index of class, zero-based)\n     */\n    static getPrediction(preds, priorClassDist, data, threshold) {\n        if (preds.length === 3) {\n            return GenModel.getPredictionBinomial(preds, threshold);\n        }\n        else {\n            return GenModel.getPredictionMultinomial(preds, priorClassDist, data);\n        }\n    }\n    static getPredictionBinomial(preds, threshold) {\n        return (preds[2] >= threshold) ? 1 : 0;\n    }\n    static getPredictionMultinomial(preds, priorClassDist, data) {\n        const ties = ([]);\n        ties.push(0);\n        let best = 1;\n        let tieCnt = 0;\n        for (let c = 2; c < preds.length; c++) {\n            {\n                if (preds[best] < preds[c]) {\n                    best = c;\n                    tieCnt = 0;\n                }\n                else if (preds[best] === preds[c]) {\n                    tieCnt++;\n                    ties.push(c - 1);\n                }\n            }\n            ;\n        }\n        if (tieCnt === 0)\n            return best - 1;\n        let hash = 0;\n        if (data != null)\n            for (let index121 = 0; index121 < data.length; index121++) {\n                let d = data[index121];\n                hash ^= (function (f) { var buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(Math.fround(d)) >> 6;\n            }\n        if (priorClassDist != null) {\n            let sum = 0;\n            for (let index122 = ties.iterator(); index122.hasNext();) {\n                let i = index122.next();\n                {\n                    sum += priorClassDist[i];\n                }\n            }\n            const rng = new java.util.Random(hash);\n            const tie = rng.nextDouble();\n            let partialSum = 0;\n            for (let index123 = ties.iterator(); index123.hasNext();) {\n                let i = index123.next();\n                {\n                    partialSum += priorClassDist[i] / sum;\n                    if (tie <= partialSum)\n                        return i;\n                }\n            }\n        }\n        const res = preds[best];\n        let idx = (hash | 0) % (tieCnt + 1);\n        for (best = 1; best < preds.length; best++) {\n            if (res === preds[best] && --idx < 0)\n                return best - 1;\n            ;\n        }\n        throw new java.lang.RuntimeException(\"Should Not Reach Here\");\n    }\n    static bitSetContains(bits, nbits, bitoff, dnum) {\n        let idx = (dnum | 0);\n        idx -= bitoff;\n        return (bits[idx >> 3] & ((1 | 0) << (idx & 7))) !== 0;\n    }\n    static bitSetIsInRange(nbits, bitoff, dnum) {\n        let idx = (dnum | 0);\n        idx -= bitoff;\n        return (idx >= 0 && idx < nbits);\n    }\n    static Kmeans_preprocessData$double_A$double_A$double_A$int_A(data, means, mults, modes) {\n        for (let i = 0; i < data.length; i++) {\n            {\n                data[i] = GenModel.Kmeans_preprocessData$double$int$double_A$double_A$int_A(data[i], i, means, mults, modes);\n            }\n            ;\n        }\n    }\n    static Kmeans_preprocessData$double$int$double_A$double_A$int_A(d, i, means, mults, modes) {\n        if (modes[i] === -1) {\n            if ( /* isNaN */isNaN(d))\n                d = means[i];\n            if (mults != null) {\n                d -= means[i];\n                d *= mults[i];\n            }\n        }\n        else {\n            if ( /* isNaN */isNaN(d))\n                d = modes[i];\n        }\n        return d;\n    }\n    static Kmeans_preprocessData(d, i, means, mults, modes) {\n        if (((typeof d === 'number') || d === null) && ((typeof i === 'number') || i === null) && ((means != null && means instanceof Array && (means.length == 0 || means[0] == null || (typeof means[0] === 'number'))) || means === null) && ((mults != null && mults instanceof Array && (mults.length == 0 || mults[0] == null || (typeof mults[0] === 'number'))) || mults === null) && ((modes != null && modes instanceof Array && (modes.length == 0 || modes[0] == null || (typeof modes[0] === 'number'))) || modes === null)) {\n            return GenModel.Kmeans_preprocessData$double$int$double_A$double_A$int_A(d, i, means, mults, modes);\n        }\n        else if (((d != null && d instanceof Array && (d.length == 0 || d[0] == null || (typeof d[0] === 'number'))) || d === null) && ((i != null && i instanceof Array && (i.length == 0 || i[0] == null || (typeof i[0] === 'number'))) || i === null) && ((means != null && means instanceof Array && (means.length == 0 || means[0] == null || (typeof means[0] === 'number'))) || means === null) && ((mults != null && mults instanceof Array && (mults.length == 0 || mults[0] == null || (typeof mults[0] === 'number'))) || mults === null) && modes === undefined) {\n            return GenModel.Kmeans_preprocessData$double_A$double_A$double_A$int_A(d, i, means, mults);\n        }\n        else\n            throw new Error('invalid overload');\n    }\n    static KMeans_closest(centers, point, domains) {\n        let min = -1;\n        let minSqr = javaemul.internal.DoubleHelper.MAX_VALUE;\n        for (let cluster = 0; cluster < centers.length; cluster++) {\n            {\n                const sqr = GenModel.KMeans_distance$double_A$double_A$java_lang_String_A_A(centers[cluster], point, domains);\n                if (sqr < minSqr) {\n                    min = cluster;\n                    minSqr = sqr;\n                }\n            }\n            ;\n        }\n        return min;\n    }\n    static KMeans_distances(centers, point, domains, distances) {\n        let min = -1;\n        let minSqr = javaemul.internal.DoubleHelper.MAX_VALUE;\n        for (let cluster = 0; cluster < centers.length; cluster++) {\n            {\n                distances[cluster] = GenModel.KMeans_distance$double_A$double_A$java_lang_String_A_A(centers[cluster], point, domains);\n                if (distances[cluster] < minSqr) {\n                    min = cluster;\n                    minSqr = distances[cluster];\n                }\n            }\n            ;\n        }\n        return min;\n    }\n    static KMeans_simplex(centers, point, domains) {\n        const dist = (s => { let a = []; while (s-- > 0)\n            a.push(0); return a; })(centers.length);\n        let sum = 0;\n        let inv_sum = 0;\n        for (let cluster = 0; cluster < centers.length; cluster++) {\n            {\n                dist[cluster] = GenModel.KMeans_distance$double_A$double_A$java_lang_String_A_A(centers[cluster], point, domains);\n                sum += dist[cluster];\n                inv_sum += 1.0 / dist[cluster];\n            }\n            ;\n        }\n        const ratios = (s => { let a = []; while (s-- > 0)\n            a.push(0); return a; })(centers.length);\n        if (sum === 0) {\n            const rng = new java.util.Random();\n            const idx = rng.nextInt(centers.length);\n            ratios[idx] = 1;\n        }\n        else {\n            let idx = -1;\n            for (let cluster = 0; cluster < centers.length; cluster++) {\n                {\n                    if (dist[cluster] === 0) {\n                        idx = cluster;\n                        break;\n                    }\n                }\n                ;\n            }\n            if (idx === -1) {\n                for (let cluster = 0; cluster < centers.length; cluster++) {\n                    ratios[cluster] = 1.0 / (dist[cluster] * inv_sum);\n                }\n            }\n            else\n                ratios[idx] = 1;\n        }\n        return ratios;\n    }\n    static KMeans_distance$double_A$float_A$int_A$double_A$double_A(center, point, modes, colSum, colSumSq) {\n        let sqr = 0;\n        let pts = point.length;\n        for (let column = 0; column < center.length; column++) {\n            {\n                const d = point[column];\n                if ( /* isNaN */isNaN(d)) {\n                    pts--;\n                    continue;\n                }\n                if (modes[column] !== -1) {\n                    if (d !== center[column]) {\n                        sqr += 1.0;\n                    }\n                    if (d !== modes[column]) {\n                        colSum[column] += 1;\n                    }\n                }\n                else {\n                    const delta = d - center[column];\n                    sqr += delta * delta;\n                    colSum[column] += d;\n                    colSumSq[column] += Math.fround(d * d);\n                }\n            }\n            ;\n        }\n        if (0 < pts && pts < point.length) {\n            const scale = point.length / pts;\n            sqr *= scale;\n        }\n        return sqr;\n    }\n    static KMeans_distance(center, point, modes, colSum, colSumSq) {\n        if (((center != null && center instanceof Array && (center.length == 0 || center[0] == null || (typeof center[0] === 'number'))) || center === null) && ((point != null && point instanceof Array && (point.length == 0 || point[0] == null || (typeof point[0] === 'number'))) || point === null) && ((modes != null && modes instanceof Array && (modes.length == 0 || modes[0] == null || (typeof modes[0] === 'number'))) || modes === null) && ((colSum != null && colSum instanceof Array && (colSum.length == 0 || colSum[0] == null || (typeof colSum[0] === 'number'))) || colSum === null) && ((colSumSq != null && colSumSq instanceof Array && (colSumSq.length == 0 || colSumSq[0] == null || (typeof colSumSq[0] === 'number'))) || colSumSq === null)) {\n            return GenModel.KMeans_distance$double_A$float_A$int_A$double_A$double_A(center, point, modes, colSum, colSumSq);\n        }\n        else if (((center != null && center instanceof Array && (center.length == 0 || center[0] == null || (typeof center[0] === 'number'))) || center === null) && ((point != null && point instanceof Array && (point.length == 0 || point[0] == null || (typeof point[0] === 'number'))) || point === null) && ((modes != null && modes instanceof Array && (modes.length == 0 || modes[0] == null || modes[0] instanceof Array)) || modes === null) && colSum === undefined && colSumSq === undefined) {\n            return GenModel.KMeans_distance$double_A$double_A$java_lang_String_A_A(center, point, modes);\n        }\n        else\n            throw new Error('invalid overload');\n    }\n    static KMeans_distance$double_A$double_A$java_lang_String_A_A(center, point, domains) {\n        let sqr = 0;\n        let pts = point.length;\n        for (let column = 0; column < center.length; column++) {\n            {\n                const d = point[column];\n                if ( /* isNaN */isNaN(d)) {\n                    pts--;\n                    continue;\n                }\n                if (domains[column] != null) {\n                    if (d !== center[column])\n                        sqr += 1.0;\n                }\n                else {\n                    const delta = d - center[column];\n                    sqr += delta * delta;\n                }\n            }\n            ;\n        }\n        if (0 < pts && pts < point.length)\n            sqr *= point.length / pts;\n        return sqr;\n    }\n    static log_rescale(preds) {\n        let maxval = javaemul.internal.DoubleHelper.NEGATIVE_INFINITY;\n        for (let k = 1; k < preds.length; k++) {\n            maxval = Math.max(maxval, preds[k]);\n        }\n        let dsum = 0;\n        for (let k = 1; k < preds.length; k++) {\n            dsum += (preds[k] = Math.exp(preds[k] - maxval));\n        }\n        return dsum;\n    }\n    static GBM_rescale(preds) {\n        const sum = GenModel.log_rescale(preds);\n        for (let k = 1; k < preds.length; k++) {\n            preds[k] /= sum;\n        }\n    }\n    static GLM_identityInv(x) {\n        return x;\n    }\n    static GLM_logitInv(x) {\n        return 1.0 / (Math.exp(-x) + 1.0);\n    }\n    static GLM_logInv(x) {\n        return Math.exp(x);\n    }\n    static GLM_inverseInv(x) {\n        const xx = (x < 0) ? Math.min(-1.0E-5, x) : Math.max(1.0E-5, x);\n        return 1.0 / xx;\n    }\n    static GLM_ologitInv(x) {\n        return GenModel.GLM_logitInv(x);\n    }\n    static GLM_tweedieInv(x, tweedie_link_power) {\n        return tweedie_link_power === 0 ? Math.max(2.0E-16, Math.exp(x)) : Math.pow(x, 1.0 / tweedie_link_power);\n    }\n    /**\n     * ???\n     * @return {string}\n     */\n    getHeader() {\n        return null;\n    }\n    static setInput$double_A$float_A$int$int$int_A$double_A$double_A$boolean$boolean(from, to, _nums, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels, replaceMissingWithZero) {\n        const nums = (s => { let a = []; while (s-- > 0)\n            a.push(0); return a; })(_nums);\n        const cats = (s => { let a = []; while (s-- > 0)\n            a.push(0); return a; })(_cats);\n        GenModel.setCats$double_A$double_A$int_A$int$int_A$double_A$double_A$boolean(from, nums, cats, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels);\n        java.util.Arrays.fill(to, 0.0);\n        for (let i = 0; i < _cats; ++i) {\n            if (cats[i] >= 0)\n                to[cats[i]] = 1.0;\n            ;\n        }\n        for (let i = 0; i < _nums; ++i) {\n            to[_catOffsets[_cats] + i] = /* isNaN */ isNaN(nums[i]) ? (replaceMissingWithZero ? 0 : javaemul.internal.FloatHelper.NaN) : Math.fround(nums[i]);\n        }\n    }\n    static setInput$double_A$double_A$double_A$int_A$int$int$int_A$double_A$double_A$boolean$boolean(from, to, nums, cats, _nums, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels, replaceMissingWithZero) {\n        GenModel.setCats$double_A$double_A$int_A$int$int_A$double_A$double_A$boolean(from, nums, cats, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels);\n        java.util.Arrays.fill(to, 0.0);\n        for (let i = 0; i < _cats; ++i) {\n            if (cats[i] >= 0)\n                to[cats[i]] = 1.0;\n            ;\n        }\n        for (let i = 0; i < _nums; ++i) {\n            to[_catOffsets[_cats] + i] = /* isNaN */ isNaN(nums[i]) ? (replaceMissingWithZero ? 0 : NaN) : nums[i];\n        }\n    }\n    static setInput(from, to, nums, cats, _nums, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels, replaceMissingWithZero) {\n        if (((from != null && from instanceof Array && (from.length == 0 || from[0] == null || (typeof from[0] === 'number'))) || from === null) && ((to != null && to instanceof Array && (to.length == 0 || to[0] == null || (typeof to[0] === 'number'))) || to === null) && ((nums != null && nums instanceof Array && (nums.length == 0 || nums[0] == null || (typeof nums[0] === 'number'))) || nums === null) && ((cats != null && cats instanceof Array && (cats.length == 0 || cats[0] == null || (typeof cats[0] === 'number'))) || cats === null) && ((typeof _nums === 'number') || _nums === null) && ((typeof _cats === 'number') || _cats === null) && ((_catOffsets != null && _catOffsets instanceof Array && (_catOffsets.length == 0 || _catOffsets[0] == null || (typeof _catOffsets[0] === 'number'))) || _catOffsets === null) && ((_normMul != null && _normMul instanceof Array && (_normMul.length == 0 || _normMul[0] == null || (typeof _normMul[0] === 'number'))) || _normMul === null) && ((_normSub != null && _normSub instanceof Array && (_normSub.length == 0 || _normSub[0] == null || (typeof _normSub[0] === 'number'))) || _normSub === null) && ((typeof useAllFactorLevels === 'boolean') || useAllFactorLevels === null) && ((typeof replaceMissingWithZero === 'boolean') || replaceMissingWithZero === null)) {\n            return GenModel.setInput$double_A$double_A$double_A$int_A$int$int$int_A$double_A$double_A$boolean$boolean(from, to, nums, cats, _nums, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels, replaceMissingWithZero);\n        }\n        else if (((from != null && from instanceof Array && (from.length == 0 || from[0] == null || (typeof from[0] === 'number'))) || from === null) && ((to != null && to instanceof Array && (to.length == 0 || to[0] == null || (typeof to[0] === 'number'))) || to === null) && ((typeof nums === 'number') || nums === null) && ((typeof cats === 'number') || cats === null) && ((_nums != null && _nums instanceof Array && (_nums.length == 0 || _nums[0] == null || (typeof _nums[0] === 'number'))) || _nums === null) && ((_cats != null && _cats instanceof Array && (_cats.length == 0 || _cats[0] == null || (typeof _cats[0] === 'number'))) || _cats === null) && ((_catOffsets != null && _catOffsets instanceof Array && (_catOffsets.length == 0 || _catOffsets[0] == null || (typeof _catOffsets[0] === 'number'))) || _catOffsets === null) && ((typeof _normMul === 'boolean') || _normMul === null) && ((typeof _normSub === 'boolean') || _normSub === null) && useAllFactorLevels === undefined && replaceMissingWithZero === undefined) {\n            return GenModel.setInput$double_A$float_A$int$int$int_A$double_A$double_A$boolean$boolean(from, to, nums, cats, _nums, _cats, _catOffsets, _normMul, _normSub);\n        }\n        else\n            throw new Error('invalid overload');\n    }\n    static setCats$double_A$double_A$int_A$int$int_A$double_A$double_A$boolean(from, nums, cats, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels) {\n        GenModel.setCats$double_A$int_A$int$int_A$boolean(from, cats, _cats, _catOffsets, useAllFactorLevels);\n        for (let i = _cats; i < from.length; ++i) {\n            {\n                let d = from[i];\n                if ((_normMul != null) && (_normMul.length > 0)) {\n                    d = (d - _normSub[i - _cats]) * _normMul[i - _cats];\n                }\n                nums[i - _cats] = d;\n            }\n            ;\n        }\n    }\n    static setCats(from, nums, cats, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels) {\n        if (((from != null && from instanceof Array && (from.length == 0 || from[0] == null || (typeof from[0] === 'number'))) || from === null) && ((nums != null && nums instanceof Array && (nums.length == 0 || nums[0] == null || (typeof nums[0] === 'number'))) || nums === null) && ((cats != null && cats instanceof Array && (cats.length == 0 || cats[0] == null || (typeof cats[0] === 'number'))) || cats === null) && ((typeof _cats === 'number') || _cats === null) && ((_catOffsets != null && _catOffsets instanceof Array && (_catOffsets.length == 0 || _catOffsets[0] == null || (typeof _catOffsets[0] === 'number'))) || _catOffsets === null) && ((_normMul != null && _normMul instanceof Array && (_normMul.length == 0 || _normMul[0] == null || (typeof _normMul[0] === 'number'))) || _normMul === null) && ((_normSub != null && _normSub instanceof Array && (_normSub.length == 0 || _normSub[0] == null || (typeof _normSub[0] === 'number'))) || _normSub === null) && ((typeof useAllFactorLevels === 'boolean') || useAllFactorLevels === null)) {\n            return GenModel.setCats$double_A$double_A$int_A$int$int_A$double_A$double_A$boolean(from, nums, cats, _cats, _catOffsets, _normMul, _normSub, useAllFactorLevels);\n        }\n        else if (((from != null && from instanceof Array && (from.length == 0 || from[0] == null || (typeof from[0] === 'number'))) || from === null) && ((nums != null && nums instanceof Array && (nums.length == 0 || nums[0] == null || (typeof nums[0] === 'number'))) || nums === null) && ((typeof cats === 'number') || cats === null) && ((_cats != null && _cats instanceof Array && (_cats.length == 0 || _cats[0] == null || (typeof _cats[0] === 'number'))) || _cats === null) && ((typeof _catOffsets === 'boolean') || _catOffsets === null) && _normMul === undefined && _normSub === undefined && useAllFactorLevels === undefined) {\n            return GenModel.setCats$double_A$int_A$int$int_A$boolean(from, nums, cats, _cats, _catOffsets);\n        }\n        else\n            throw new Error('invalid overload');\n    }\n    static setCats$double_A$int_A$int$int_A$boolean(from, to, cats, catOffsets, useAllFactorLevels) {\n        for (let i = 0; i < cats; ++i) {\n            {\n                if ( /* isNaN */isNaN(from[i])) {\n                    to[i] = (catOffsets[i + 1] - 1);\n                }\n                else {\n                    const c = (from[i] | 0);\n                    if (useAllFactorLevels)\n                        to[i] = c + catOffsets[i];\n                    else {\n                        if (c !== 0)\n                            to[i] = c - 1 + catOffsets[i];\n                        else\n                            to[i] = -1;\n                    }\n                    if (to[i] >= catOffsets[i + 1])\n                        to[i] = (catOffsets[i + 1] - 1);\n                }\n            }\n            ;\n        }\n    }\n    static convertDouble2Float(input) {\n        const arraySize = input.length;\n        const output = (s => { let a = []; while (s-- > 0)\n            a.push(0); return a; })(arraySize);\n        for (let index = 0; index < arraySize; index++) {\n            output[index] = Math.fround(input[index]);\n        }\n        return output;\n    }\n}\nGenModel[\"__class\"] = \"GenModel\";\nexports.GenModel=GenModel;\n",
    "const {GenModel}=require(\"./GenModel.js\");\n/* Generated from Java with JSweet 3.0.0 - http://www.jsweet.org */\nclass glm_model {\n    isSupervised() {\n        return true;\n    }\n    nfeatures() {\n        return 4;\n    }\n    nclasses() {\n        return 2;\n    }\n    static NAMES_$LI$() { if (glm_model.NAMES == null) {\n        glm_model.NAMES = NamesHolder_glm_model.VALUES_$LI$();\n    } return glm_model.NAMES; }\n    static DOMAINS_$LI$() { if (glm_model.DOMAINS == null) {\n        glm_model.DOMAINS = [glm_model_ColInfo_0.VALUES_$LI$(), null, null, null, glm_model_ColInfo_4.VALUES_$LI$()];\n    } return glm_model.DOMAINS; }\n    getUUID() {\n        return /* toString */ ('' + (141935666827635768));\n    }\n    score0(data, preds) {\n        const b = glm_model.BETA.VALUES_$LI$();\n        for (let i = 0; i < 1; ++i) {\n            if ( /* isNaN */isNaN(data[i]))\n                data[i] = glm_model.CAT_MODES.VALUES_$LI$()[i];\n            ;\n        }\n        for (let i = 0; i < 3; ++i) {\n            if ( /* isNaN */isNaN(data[i + 1]))\n                data[i + 1] = glm_model.NUM_MEANS.VALUES_$LI$()[i];\n            ;\n        }\n        let eta = 0.0;\n        for (let i = 0; i < glm_model.CATOFFS_$LI$().length - 1; ++i) {\n            {\n                let ival = (data[i] | 0);\n                if (ival !== data[i])\n                    throw new java.lang.IllegalArgumentException(\"categorical value out of range\");\n                ival += glm_model.CATOFFS_$LI$()[i];\n                if (ival < glm_model.CATOFFS_$LI$()[i + 1])\n                    eta += b[ival];\n            }\n            ;\n        }\n        for (let i = 1; i < b.length - 1 - 1; ++i) {\n            eta += b[1 + i] * data[i];\n        }\n        eta += b[b.length - 1];\n        const mu = GenModel.GLM_logitInv(eta);\n        preds[0] = (mu >= 0.3013814467120079) ? 1 : 0;\n        preds[1] = 1.0 - mu;\n        preds[2] = mu;\n        return preds;\n    }\n    static CATOFFS_$LI$() { if (glm_model.CATOFFS == null) {\n        glm_model.CATOFFS = [0, 2];\n    } return glm_model.CATOFFS; }\n}\nglm_model.NCLASSES = 2;\nglm_model.PRIOR_CLASS_DISTRIB = null;\nglm_model.MODEL_CLASS_DISTRIB = null;\nglm_model[\"__class\"] = \"glm_model\";\n(function (glm_model) {\n    class BETA {\n        constructor() {\n        }\n        static __static_initialize() { if (!BETA.__static_initialized) {\n            BETA.__static_initialized = true;\n            BETA.__static_initializer_0();\n        } }\n        static VALUES_$LI$() { BETA.__static_initialize(); if (BETA.VALUES == null) {\n            BETA.VALUES = [0, 0, 0, 0, 0, 0];\n        } return BETA.VALUES; }\n        static __static_initializer_0() {\n            BETA.BETA_0.fill(BETA.VALUES_$LI$());\n        }\n    }\n    BETA.__static_initialized = false;\n    glm_model.BETA = BETA;\n    BETA[\"__class\"] = \"glm_model.BETA\";\n    BETA[\"__interfaces\"] = [\"java.io.Serializable\"];\n    (function (BETA) {\n        class BETA_0 {\n            static fill(sa) {\n                sa[0] = 0.2502528707088587;\n                sa[1] = -0.24203900661628655;\n                sa[2] = -0.021574877311133958;\n                sa[3] = 0.02823624475366092;\n                sa[4] = 1.072934769711424;\n                sa[5] = -6.531154239276896;\n            }\n            constructor() {\n            }\n        }\n        BETA.BETA_0 = BETA_0;\n        BETA_0[\"__class\"] = \"glm_model.BETA.BETA_0\";\n        BETA_0[\"__interfaces\"] = [\"java.io.Serializable\"];\n    })(BETA = glm_model.BETA || (glm_model.BETA = {}));\n    class NUM_MEANS {\n        constructor() {\n        }\n        static __static_initialize() { if (!NUM_MEANS.__static_initialized) {\n            NUM_MEANS.__static_initialized = true;\n            NUM_MEANS.__static_initializer_0();\n        } }\n        static VALUES_$LI$() { NUM_MEANS.__static_initialize(); if (NUM_MEANS.VALUES == null) {\n            NUM_MEANS.VALUES = [0, 0, 0];\n        } return NUM_MEANS.VALUES; }\n        static __static_initializer_0() {\n            NUM_MEANS.NUM_MEANS_0.fill(NUM_MEANS.VALUES_$LI$());\n        }\n    }\n    NUM_MEANS.__static_initialized = false;\n    glm_model.NUM_MEANS = NUM_MEANS;\n    NUM_MEANS[\"__class\"] = \"glm_model.NUM_MEANS\";\n    NUM_MEANS[\"__interfaces\"] = [\"java.io.Serializable\"];\n    (function (NUM_MEANS) {\n        class NUM_MEANS_0 {\n            static fill(sa) {\n                sa[0] = 66.03947368421103;\n                sa[1] = 15.408631578947343;\n                sa[2] = 6.384210526315727;\n            }\n            constructor() {\n            }\n        }\n        NUM_MEANS.NUM_MEANS_0 = NUM_MEANS_0;\n        NUM_MEANS_0[\"__class\"] = \"glm_model.NUM_MEANS.NUM_MEANS_0\";\n        NUM_MEANS_0[\"__interfaces\"] = [\"java.io.Serializable\"];\n    })(NUM_MEANS = glm_model.NUM_MEANS || (glm_model.NUM_MEANS = {}));\n    class CAT_MODES {\n        constructor() {\n        }\n        static __static_initialize() { if (!CAT_MODES.__static_initialized) {\n            CAT_MODES.__static_initialized = true;\n            CAT_MODES.__static_initializer_0();\n        } }\n        static VALUES_$LI$() { CAT_MODES.__static_initialize(); if (CAT_MODES.VALUES == null) {\n            CAT_MODES.VALUES = [0];\n        } return CAT_MODES.VALUES; }\n        static __static_initializer_0() {\n            CAT_MODES.CAT_MODES_0.fill(CAT_MODES.VALUES_$LI$());\n        }\n    }\n    CAT_MODES.__static_initialized = false;\n    glm_model.CAT_MODES = CAT_MODES;\n    CAT_MODES[\"__class\"] = \"glm_model.CAT_MODES\";\n    CAT_MODES[\"__interfaces\"] = [\"java.io.Serializable\"];\n    (function (CAT_MODES) {\n        class CAT_MODES_0 {\n            static fill(sa) {\n                sa[0] = 0;\n            }\n            constructor() {\n            }\n        }\n        CAT_MODES.CAT_MODES_0 = CAT_MODES_0;\n        CAT_MODES_0[\"__class\"] = \"glm_model.CAT_MODES.CAT_MODES_0\";\n        CAT_MODES_0[\"__interfaces\"] = [\"java.io.Serializable\"];\n    })(CAT_MODES = glm_model.CAT_MODES || (glm_model.CAT_MODES = {}));\n})(glm_model || (glm_model = {}));\nclass NamesHolder_glm_model {\n    constructor() {\n    }\n    static __static_initialize() { if (!NamesHolder_glm_model.__static_initialized) {\n        NamesHolder_glm_model.__static_initialized = true;\n        NamesHolder_glm_model.__static_initializer_0();\n    } }\n    static VALUES_$LI$() { NamesHolder_glm_model.__static_initialize(); if (NamesHolder_glm_model.VALUES == null) {\n        NamesHolder_glm_model.VALUES = [null, null, null, null];\n    } return NamesHolder_glm_model.VALUES; }\n    static __static_initializer_0() {\n        NamesHolder_glm_model.NamesHolder_glm_model_0.fill(NamesHolder_glm_model.VALUES_$LI$());\n    }\n}\nNamesHolder_glm_model.__static_initialized = false;\nNamesHolder_glm_model[\"__class\"] = \"NamesHolder_glm_model\";\nNamesHolder_glm_model[\"__interfaces\"] = [\"java.io.Serializable\"];\n(function (NamesHolder_glm_model) {\n    class NamesHolder_glm_model_0 {\n        static fill(sa) {\n            sa[0] = \"RACE\";\n            sa[1] = \"AGE\";\n            sa[2] = \"PSA\";\n            sa[3] = \"GLEASON\";\n        }\n        constructor() {\n        }\n    }\n    NamesHolder_glm_model.NamesHolder_glm_model_0 = NamesHolder_glm_model_0;\n    NamesHolder_glm_model_0[\"__class\"] = \"NamesHolder_glm_model.NamesHolder_glm_model_0\";\n    NamesHolder_glm_model_0[\"__interfaces\"] = [\"java.io.Serializable\"];\n})(NamesHolder_glm_model || (NamesHolder_glm_model = {}));\nclass glm_model_ColInfo_0 {\n    constructor() {\n    }\n    static __static_initialize() { if (!glm_model_ColInfo_0.__static_initialized) {\n        glm_model_ColInfo_0.__static_initialized = true;\n        glm_model_ColInfo_0.__static_initializer_0();\n    } }\n    static VALUES_$LI$() { glm_model_ColInfo_0.__static_initialize(); if (glm_model_ColInfo_0.VALUES == null) {\n        glm_model_ColInfo_0.VALUES = [null, null];\n    } return glm_model_ColInfo_0.VALUES; }\n    static __static_initializer_0() {\n        glm_model_ColInfo_0.glm_model_ColInfo_0_0.fill(glm_model_ColInfo_0.VALUES_$LI$());\n    }\n}\nglm_model_ColInfo_0.__static_initialized = false;\nglm_model_ColInfo_0[\"__class\"] = \"glm_model_ColInfo_0\";\nglm_model_ColInfo_0[\"__interfaces\"] = [\"java.io.Serializable\"];\n(function (glm_model_ColInfo_0) {\n    class glm_model_ColInfo_0_0 {\n        static fill(sa) {\n            sa[0] = \"1\";\n            sa[1] = \"2\";\n        }\n        constructor() {\n        }\n    }\n    glm_model_ColInfo_0.glm_model_ColInfo_0_0 = glm_model_ColInfo_0_0;\n    glm_model_ColInfo_0_0[\"__class\"] = \"glm_model_ColInfo_0.glm_model_ColInfo_0_0\";\n    glm_model_ColInfo_0_0[\"__interfaces\"] = [\"java.io.Serializable\"];\n})(glm_model_ColInfo_0 || (glm_model_ColInfo_0 = {}));\nclass glm_model_ColInfo_4 {\n    constructor() {\n    }\n    static __static_initialize() { if (!glm_model_ColInfo_4.__static_initialized) {\n        glm_model_ColInfo_4.__static_initialized = true;\n        glm_model_ColInfo_4.__static_initializer_0();\n    } }\n    static VALUES_$LI$() { glm_model_ColInfo_4.__static_initialize(); if (glm_model_ColInfo_4.VALUES == null) {\n        glm_model_ColInfo_4.VALUES = [null, null];\n    } return glm_model_ColInfo_4.VALUES; }\n    static __static_initializer_0() {\n        glm_model_ColInfo_4.glm_model_ColInfo_4_0.fill(glm_model_ColInfo_4.VALUES_$LI$());\n    }\n}\nglm_model_ColInfo_4.__static_initialized = false;\nglm_model_ColInfo_4[\"__class\"] = \"glm_model_ColInfo_4\";\nglm_model_ColInfo_4[\"__interfaces\"] = [\"java.io.Serializable\"];\n(function (glm_model_ColInfo_4) {\n    class glm_model_ColInfo_4_0 {\n        static fill(sa) {\n            sa[0] = \"0\";\n            sa[1] = \"1\";\n        }\n        constructor() {\n        }\n    }\n    glm_model_ColInfo_4.glm_model_ColInfo_4_0 = glm_model_ColInfo_4_0;\n    glm_model_ColInfo_4_0[\"__class\"] = \"glm_model_ColInfo_4.glm_model_ColInfo_4_0\";\n    glm_model_ColInfo_4_0[\"__interfaces\"] = [\"java.io.Serializable\"];\n})(glm_model_ColInfo_4 || (glm_model_ColInfo_4 = {}));\nglm_model_ColInfo_4.__static_initialize();\nglm_model_ColInfo_0.__static_initialize();\nNamesHolder_glm_model.__static_initialize();\nglm_model.CAT_MODES.__static_initialize();\nglm_model.NUM_MEANS.__static_initialize();\nglm_model.BETA.__static_initialize();\nexports.glm_model=glm_model;\n",
    "const {glm_model} = require(\"./glm_model\");\n\nlet m = new glm_model();\npred = new Array(3).fill(0);\n\nvar race = document.getElementById(\"race\").value;\nvar age = document.getElementById(\"age\").value;\nvar psa = document.getElementById(\"psa\").value;\nvar gleason = document.getElementById(\"gleason\").value;\n\nrace = parseFloat(race);\nage = parseFloat(age);\npsa = parseFloat(psa);\ngleason = parseFloat(gleason);\n\ninput = [race, age, psa, gleason];\np = m.score0(input, pred);\n\ndocument.getElementById(\"h2oAnswer\").innerHTML = p;\n"
  ]
}